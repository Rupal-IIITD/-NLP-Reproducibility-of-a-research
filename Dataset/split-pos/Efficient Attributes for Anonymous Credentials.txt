Efﬁcient Attributes for Anonymous Credentials

Jan Camenisch and Thomas Groß

IBM Research, Zurich Research Laboratory

September 27, 2010

Abstract

We extend the Camenisch-Lysyanskaya anonymous credential system such that selective disclosure
of attributes becomes highly efﬁcient. The resulting system signiﬁcantly improves upon existing ap-
proaches, which suffer from a linear complexity in the total number of attributes. This limitation makes
them unﬁt for many practical applications, such as electronic identity cards. Our system can incorporate
an large number of binary and ﬁnite-set attributes without signiﬁcant performance impact. Our approach
compresses all such attributes into a single attribute base and, thus, boosts the efﬁciency of all proofs of
possession. The core idea is to encode discrete binary and ﬁnite-set values as prime numbers. We use
the divisibility property for efﬁcient proofs of their presence or absence. We contribute efﬁcient methods
for conjunctions and disjunctions, in addition. The system builds on the Strong-RSA assumption.

We demonstrate the aptness of our method in realistic application scenarios, such as electronic iden-
tity cards and complex/structured credentials. Our method has crucial advantages in devices with re-
stricted computational capabilities, such as smartcards and cell phones.

1 Introduction

The rise of user-centric identity management ampliﬁes the need for a combination of strong security and
privacy protection. Anonymous credential systems are one of the most promising answers to this need. They
allow users to selectively prove statements about their identity attributes while keeping the corresponding
data hidden.

Industry does not only aim at employing anonymous credential systems on desktop PCs but also on small
devices with very limited computational power. Examples include cell phones and corporate or government-
issued electronic identity cards. In these environments, one fundamental complexity restriction amounts to
a limiting factor: The complexity of a proof of possession is linear in the total number of attributes in the
credential [10, 13].

European electronic identity cards, for instance, often contain several attributes: Nationality, sex, civil
status, hair and eye color, and applicable minority status1. These attributes are either binary or discrete
values from pre-deﬁned ﬁnite sets. They constitute the lion’s share of the encoded attributes. These attributes
are partially highly privacy-sensitive and require a selective disclosure of one attribute while hiding others
completely. The traditional encoding renders anonymous credential systems impractical for implementation
on small devices, e.g., electronic identity cards. We therefore focus on new and efﬁcient means to encode
binary and ﬁnite-set attributes.

There exist two prior approaches for encoding binary or ﬁnite-set attributes in anonymous credential
systems: First, encoding each binary attribute in one attribute base (i.e., as one exponent in a discrete

1such as blind, partially sighted, spectacles wearer, or hearing impaired

1

logarithm representation). We call this method traditional encoding. This method is directly impacted
by the mentioned complexity restriction: proofs of possession are linear in the total number of attribute
bases. Therefore, each binary attribute burdens all credential transactions. This traditional approach denies
applications with small devices and a signiﬁcant number of binary/ﬁnite-set attributes.

A second prior approach encodes binary attributes as bit vector in one attribute base. Clearly, this
approach limits the number of attribute bases required. It therefore circumvents the linear computational
complexity in the total attribute number. However, as soon as a user reveals some of the attributes in the bit
vector the complexity is linear again. It is either impacted by the total number of (binary) attributes con-
cerned or by the length of the bit vector, depending on the particular implementation. Hence this approach
is also unacceptable for small devices.

We extend the Camenisch-Lysyanskaya credential system [13, 15] with a ﬁnite-set encoding. It enables
the efﬁcient selective disclosure of binary and discrete-values attributes. This method overcomes the severe
limitations of existing schemes. We require a solution with two key properties: (1) It only uses at most
one attribute base for all binary and ﬁnite-set attributes. (2) It only impacts the proof complexity by the
number of used attributes instead of the total number. Our extension provides a highly efﬁcient toolkit of
attribute proofs as well as AND, OR, and NOT proofs over binary or ﬁnite-set attributes. Our approach has
a constant complexity in the number of encodable attributes. It is only restricted by space considerations for
the attribute exponent length in the credential and the size of the issuer’s public key.

This is the core idea of our paper: We encode binary attributes as well as discrete values of ﬁnite sets
as product of prime numbers in a single attribute base. We use the coprime property to efﬁciently prove
the attributes’ presence and absence. We also employ this property to facilitate conjunction and disjunction
proofs. Where earlier schemes prove equality of exponents, we prove divisibility. The efﬁciency of our
scheme surpasses any existing encoding of binary and ﬁnite-set attributes.

We note that other cryptographic primitives with privacy protection can also beneﬁt from our approach,

particularly group signatures, blind signatures, and electronic voting schemes.

We structure the remainder of this paper as follows: Section 2 covers related literature for anonymous
credential systems as well as existing methods for encoding binary attributes. Section 3 contains prelim-
inary deﬁnitions including the Camenisch-Lysyanskaya credential system. We deﬁne our prime encoding
extensions for binary and ﬁnite-set attributes in Section 4. Section 4.1 contains the attribute representation
in CL signatures, followed by setup and encoding paradigm. We treat proofs with AND, OR, and NOT
statements in Section 4.4. We analyze the complexity of our scheme compared to existing approaches in
Section 5. Section 6 governs possible application scenarios such as electronic identity cards and role-based
access control. We conclude the paper in Section 7. Our Appendix digresses in three areas: We provide a
formal protocol speciﬁcation for setup and issuing in Appendix Section A. Appendix Section B elaborates
on the impact of the bitlength of the prime encoding. Appendix Section C considers professional taxonomies
as additional application example.

2 Related Works

Chaum pioneered privacy-enhancing cryptographic protocols that minimize the amount of personal data
disclosed. His work put forth the principles of anonymous credentials [21, 23, 24], group signatures [26],
and electronic cash [22]. These concepts have in common that some party issue a digital signatures where
the message signed includes information about the user (i.e., attributes). Subsequently, more efﬁcient imple-
mentation of these concepts were proposed and a number of related concepts where introduced, including,
group signatures [3, 4, 35], e-cash [6, 12, 30], anonymous credentials [7, 8, 10, 13, 16], traceable signa-

2

tures [36], anonymous auctions [37], and electronic voting based on blind-signatures [31]. Many of these
schemes use as building blocks signed attributes and protocols that selectively reveal these attributes or
prove properties about them. The given implementations typically encode attributes as a discrete logarithm
or, more generally, as an element (exponent) of a representation of a group element, resulting in protocols
where the number of group elements transmitted and the commutations performed are linear in the number
of encoded attributes.

There are also some works [27, 9, 17, 5, 32] where the respective authors propose zero-knowledge proof
techniques for proving AND, OR and NOT statement about attributes encoded as discrete logarithms, e.g.,
“a user has attribute a OR b,” basically by showing that some committed value equals a given value OR
some other given value.

We signiﬁcantly improve on the existing works: our proof-protocols for showing that some given at-
tribute value is encoded in a credential is much more efﬁcient. Also, the proof protocols for proving AND,
OR, and NOT statements are far more efﬁcient than the known ones.

3 Preliminaries

3.1 Assumptions

Strong RSA Assumption [39, 32]: Given an RSA modulus n and a random element g ∈ Z∗
n, it is hard to
compute h ∈ Z∗
n and integer e > 1 such that he ≡ g mod n. The modulus n is of a special form pq,
where p = 2p′ + 1 and q = 2q′ + 1 are safe primes. Other primitives, such as the Fiat-Shamir heuristic to
generate signatures from zero-knowledge proofs of knowledge, may require additional assumptions. This is
orthogonal to the credential system itself.

3.2

Integer Commitments

Recall the Pedersen commitment scheme [38], in which the public parameters are a group G of prime order
q, and generators (g0, . . . , gm). In order to commit to the values (v1, . . . , vm) ∈ Zm
q , pick a random r ∈ Zq
and set C = Com(v1, . . . , vm; r) = gr

Damg˚ard and Fujisaki [28] show that if the group G is an RSA group and the committer is not privy of
the factorization of the modulus, then in fact the Pedersen commitment scheme can be used to commit to
integers of arbitrary size.

0 Qm

i=1 gvi
i .

3.3 Known Discrete-Logarithm-Based, Zero-Knowledge Proofs

In the common parameters model, we use several previously known results for proving statements about
discrete logarithms, such as (1) proof of knowledge of a discrete logarithm modulo a prime [40] or a com-
posite [28, 32], (2) proof of knowledge of equality of representation modulo two (possibly different) prime
[25] or composite [17] moduli, (3) proof that a commitment opens to the product of two other committed
values [9, 17, 19], (4) proof that a committed value lies in a given integer interval [5, 17, 20], and also (5)
proof of the disjunction or conjunction of any two of the previous [27]. These protocols modulo a composite
are secure under the strong RSA assumption and modulo a prime under the discrete logarithm assumption.
When referring to the proofs above, we will follow the notation introduced by Camenisch and Stadler
[18] for various proofs of knowledge of discrete logarithms and proofs of the validity of statements about
discrete logarithms. For instance,

PK {(α, β, δ) : y = gαhβ ∧ ˜y = ˜gα˜hδ ∧ (u ≤ α ≤ v)}

3

denotes a “zero-knowledge Proof of Knowledge of integers α, β, and δ such that y = gαhβ and ˜y = ˜gα˜hδ
holds, where u ≤ α ≤ v,1” where y, g, h, ˜y, ˜g, and ˜h are elements of some groups G = hgi = hhi and
˜G = h˜gi = h˜hi. The convention is that Greek letters denote quantities of which knowledge is being proven,
while all other values are known to the veriﬁer. We apply the Fiat-Shamir heuristic [29] to turn such proofs
of knowledge into signatures on some message m; denoted as, e.g., SPK {(α) : y = gα}(m).

Given a protocol in this notation, it is straightforward to derive actual protocol implementing the proof.
Indeed, the computational complexities of the proof protocol can be easily derived from this notation: basi-
cally for each term y = gαhβ, the prover and the veriﬁer have to perform an equivalent computation, and to
transmit one group element and one response value for each exponent. With statement such as (u ≤ α ≤ v)
we denote interval checks which are basically free [17, 20] but are not tight (however, good enough if the
non-tightness can be accounted for as in our application). We note that this exclude the interval proof pro-
tocol as the one by [5] that are tight but computationally costly, i.e., they require the prover to provide a
number of so-called integer commitments and to prove relations among them.

3.4 Camenisch-Lysyanskaya Signatures

Let us recall Camenisch-Lysyanskaya signatures [15] (we present a slight and straightforward variant which
allows messages to be negative integers as well). Let ℓm, ℓe, ℓn, ℓr and L be system parameters. ℓr is a
security parameter, the meanings of the others will become apparent soon.

Throughout the paper, we denote by {0, 1}ℓm the set of integer {−(2ℓm − 1), ...., 2ℓm − 1)}. Element
of this set can thus be encoded as binary strings of length ℓm plus an additional bit carrying the sign, i.e,
ℓm + 1 bits in total.
Key generation. On input ℓn, choose an ℓn-bit RSA modulus n such that n = pq, p = 2p′ + 1, q = 2q′ + 1,
where p, q, p′, and q′ are primes. Choose, uniformly at random, R0, . . . , RL−1, S, Z ∈ QRn. Output the
public key (n, R0, . . . , RL−1, S, Z) and the secret key p.

Message space is the set {(m0, . . . , mL−1) : mi ∈ ±{0, 1}ℓm}.

Signing algorithm. On input m0, . . . , mL−1 , choose a random prime number e of length ℓe > ℓm + 2,
and a random number v of length ℓv = ℓn + ℓm + ℓr, where ℓr is a security parameter. Compute
A = (

L−1 Sv )1/e mod n . The signature consists of (e, A, v).

Z
mL−1
...R

m0
0

R

Veriﬁcation algorithm. To verify that the tuple (e, A, v) is a signature on message (m0, . . . , mL−1), check
that
Z ≡ AeRm0

L−1 Sv (mod n), mi ∈ ±{0, 1}ℓm, and 2ℓe > e > 2ℓe−1 holds.

. . . RmL−1

0

Theorem 3.1. [15] The signature scheme is secure against adaptive chosen message att [33] under the
strong RSA assumption.

Proving Knowledge of a Signature. Let us further recall how a prover can prove that she possesses a CL
signature without revealing any other information about the signature.

Of course we want to use the protocols described in §3.3. Now, if A was a public value, we could do
so by proving knowledge representation of Z w.r.t. R0, . . . , RL−1, S, and A. Obviously making A public
would destroy privacy as that would make all transaction linkable. Luckily, one can randomize A: Given a
signature (A, e, v), the tuple (A′ := AS−r mod n, e, v′ := v + er) is also a valid signature as well. Now,
provided that A ∈ hSi and that r is chosen uniformly at random from {0, 1}ℓn+ℓ∅ , the value A′ is distributed

4

statistically close to uniform over Z∗
run the protocol

n. Thus, the user could compute a fresh A′ each time, reveal it, and then

PK{(ε, ν′, µ0, . . . , µL−1) :
0 · · · RµL−1

Z ≡ ±Rµ0
µi ∈ ±{0, 1}ℓm ∧ ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

L−1 A′εSν′

(mod n) ∧

Now, there is a technical consequence from this proof protocol regarding the statements µi ∈ ±{0, 1}ℓm ∧
ε ∈ [2ℓe−1 + 1, 2ℓe − 1]. While these can be implemented virtually for free, they requires that the actually
secret lie in a smaller interval, i.e., the signer needs to choose e from [2ℓe−1 − 2ℓ′
e − 1]
with ℓ′
e < ℓe − ℓ∅ − ℓH − 3, where ℓ∅ and ℓH are security parameters (the ﬁrst controlling statistical
zero-knowledge and the second one being the size of the challenge message in the PK protocol). Similarly,
we require mi ∈ ±{0, 1}ℓm−ℓ∅ −ℓH−2 when input to the signature scheme (cf. [15]). As the proofs can only
guarantee that the absolute value of the messages are smaller then 2ℓm we also include negative message
in the message space for consistency. Finally, we note that in Z ≡ ±Rµ0
(mod n) there
appears a ±. This is a technicality in the used proofs of knowledge in RSA. While this is not a problem for
the application at hand, we refer to the standard literature for details.

e + 1, 2ℓe−1 + 2ℓ′

0 · · · RµL−1

L−1 A′εSν′

3.5 Traditional Encoding of Attributes and Proofs About Them

We discuss how attributes are typically encoded in privacy-enhancing primitives found in the literature.
While we focus on CL signatures, the principles are the same in other settings.

As we have seen in the previous subsection, CL signatures allow one to sign several messages such that
later on one can prove knowledge of a signature without revealing the signature nor the signed messages.
Now, if each attribute is encoded as a single message, revealing these attributes selectively can be done using
the zero-knowledge protocol discussed above as follows. Assume for example that messages m1 and m3
encode the attributes that one wants to reveal. Then the protocol will be as follows:

PK{(ε, ν′, µ0, µ2, µ4, . . . , µL−1) :

3

L−1 A′εSν′

(mod n) ∧

1 R−m3

ZR−m1
µi ∈ ±{0, 1}ℓm ∧ ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

4 · · · RµL−1

≡ ±Rµ0

0 Rµ2

2 Rµ4

If one wanted to encode binary attributes (or attributes that take on only a few ﬁxed values), this approach
of selectively revealing attributes requires one to encode each attribute value (a single or only a few bits) as
a full ℓm-bit message. Thus, if a large number of such attributes shall be encoded, this approach would not
be very efﬁcient: The computation and the number of group elements to be exchanged in the proof protocol
would be linear in the number of attributes.

As an alternative, one could encode all the binary attributes as a bit vector and then include that vector in
a single message (or several ones, depending on the number of attributes). The resulting proof for revealing
attributes selectively seems in general to require to commit to each individual attribute, proving that each
commitment indeed only commits to a binary value, prove that these committed values correspond to the
certiﬁed message, and then to reveal the attribute by opening the commitments. The communication and
computational complexities of the resulting protocol would be even worse than of the one discussed priorly.
Now, if only a single attribute should be revealed, one could obtain a more efﬁcient proof protocol as
follows. That is, if the vector looked as (akbkc), where b is the representation of the attribute that shall be

5

revealed and a and c are the representations of the remaining attributes, one would provide a commitment
to a and c and then prove (1) that these have the right binary length and (2) that (akbkc) indeed is signed
by the issuer (without revealing a or c of course). A proof that a commitment contains a ℓ-bit number can
be done relatively efﬁcient with the range proof proposed by Boudot [5]. While this solution provides a
proof protocol that does not depend on the number of attributes encoded, each range proofs require about 12
commitments plus some additional values, and one needs to do l+1 of them if l attributes are revealed. Even
if one wanted to apply this for revealing a single attribute, this would in practice not be considered efﬁcient
anymore. This holds in particular if one considers using anonymous credentials for electronic identity cards.
Indeed, for the scenarios we consider in the application section, it would even be more efﬁcient to use the
other methods we discussed.

4 Efﬁcient Attributes for CL

In this section we, provide the means to efﬁciently encode a number of attributes into an anonymous creden-
tial. We focus on the computational cost when issuing and using a credential (note that the communication
cost when using a credential is directly related to the computational cost—hence we only consider the latter).
That is, we show how to encode attribute values as (small) prime values such that a number of attributes can
be encoded into a single message mj. We also show how one can reveal these attribute values selectively
and how one can prove simple statements about them (OR, AND, and NOT connectives). Our basic idea is
in fact very simple: we set mj equal to the product of the primes corresponding the values of the different
attributes. Now that allows us to show that an attribute is set to a given value encoded by, say prime ej by
prooﬁng that ej divides the message contained in the credential. We can also show that it is not set to the
given value by showing that ej does not divide the message. Realizing OR statements, i.e., that the creden-
tial encoded either ej or el can be done by proving that there exists a value that divides both the product of
ej and el as well as the message contained in the credential. As we will see, this idea gives us very efﬁcient
proof statements and leads to, e.g., an efﬁcient implementation of an electronic identity card.

While we present the method for encoding attributes in context of the RSA-based CL credential sys-
tem [13, 15], it can be applied as well to other anonymity related schemes such as group signatures, e-cash
systems, or voting schemes.

4.1 The CL Credential System and Attributes

We provide an explanation of how the Camenisch-Lysyanskaya (CL) credential system [13, 15] works and
how attributes can be encoded into credentials. This will make it clear how to use the results presented in
the remainder of this section to build a fully ﬂedge credential systems with all other features with which
the basic system has been extended over the years and as described in the literature (e.g., revocation [14],
k-spendability [12], clone protection [11]).

In the CL credential system each user has a secret identity, i.e., a single secret key sU . In contrast to how
credentials are issued to the user in a traditional PKI (e.g, X.509), an issuing party now uses the CL signature
scheme to sign the user’s secret key as well as all attributes the issuer wants to assert about the user. This
signing is of course done in a “blind” way such the issuer does not learn the user’s secret key (cf. [13, 15]).
Thus, the user will have obtained a signature (A, e, v) such that Z ≡ ±Rsu
(mod n)
holds, where a1, . . . , aL−1 are the attested attributes and (Z, R0, . . . , RL−1, S, n) are the issuer’s public
key. How a user can show that she obtained a credential from some issuer and selectively reveal some of the
attributes (or prove statement about them, e.g., my attested birth date lies further in the past than 21 years)

1 · · · RaL−1

0 Ra1

L−1 A′εSν′

6

using the proof of knowledge of a signature that we recalled in the previous section.

As discussed, our approach to achieve efﬁcient encoding and proving of attributes for the CL credential
system, we are going to encode products of primes into a user’s credential, e.g., we set a1 as the product of
the relevant primes ej. Thus, it remains to show how the user can selectively reveal attribute values encoded
like this, that one out of a list of attribute values is encoded, or that an attribute value is not encoded into her
credential.

4.2 Set Up

The issuer performs the following setup. On input ℓn, choose an ℓn-bit RSA modulus n such that
n = pq, p = 2p′ + 1, q = 2q′ + 1, where p, q, p′, and q′ are primes. Choose, uniformly at random,
R0, . . . , RL−1, S, Z ∈ QRn. In addition, we require bases g and h for an integer commitment. For this,
we can use the signer’s RSA modulus as well, thus, let h and g be element of QRn. We establish a further
group for our new OR-proofs. It has prime order q. We choose two generators g and h of that group such
that logh g is unknown.

The public key becomes (n, R0, . . . , RL−1, S, Z, g, h, g, h).

4.3 Encoding

The number of bits we can encode into a message ﬁeld of a CL signature is ℓm as described in the previous
section. Now assume we wants to encode t attributes into a single message ﬁled. Thus we can only use
primes of length up to ℓm/t. Now, if we each attributes takes at most k different values, then we need
choose our ℓm such that there exist tk primes smaller than 2ℓm/t (or, alternatively, choose t and encode the
attributes into two or more messages). Let ℓt < ℓm/t be the length of the primes that we will be using. See
also Appendix Section B

Assume we want to encode the attribute vector (a1, ...., at) with ai ∈ {1, . . . , k} and that we have
enumerated all the primes 2 < ei < 2ℓm/t. Now we encode (a1, ...., at) by including the value E =
Qt
j=1 e((j−1)k+aj ) in the credential. This means that the product E will be one of the messages that the
issuer signs. (Here we assumed that each attribute takes k different values — adapting the construction to
cases where some attributes take fewer values is straightforward.)

4.4 Proofs About Attributes

We now assume that the user (prover) has obtained a CL credential containing E, i.e., signature (A, e, v) on
messages m0 and m1 with m1 = E. (The attribute m0 typically encodes the user’s secret key [15]).

Efﬁciently proving that a credential contains an attribute with a given value

Let us ﬁrst discuss has the user can convince the veriﬁer that E encodes a given attribute, e.g, how she can
prove that her identity card states that her hair color is blond. Assume that the attribute hair color blond is
encoded by the prime ej. Thus to convince the veriﬁer that she got issues a credential with this attribute, i.e.,

7

that ej divides the E included in her credential, the user engages with the following proof with the veriﬁer:

1) :
0 (Rej

PK{(ε, ν′, µ0, µ′
Z ≡ ±Rµ0
µ0 ∈ ±{0, 1}ℓm ∧ µ′
ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

1 )µ′

1A′εSν′

(mod n)∧

1 ∈ ±{0, 1}ℓm−ℓt∧

Theorem 4.1. If a prover is successful in the above protocol, he was issued a credential encoding the
attribute corresponding to ej.

1 such that Z ≡ tRµ0

Proof. It is standard to show that there exists a knowledge extractor who can extract from a convincing
prover values ε, ν′, µ0, µ′
(mod n) holds for some t (see, e.g., [28]).
Moreover, as we have chosen n as the product of two safe primes, t must be ±1. Now, as CL signatures are
unforgeable we can conclude that there must exist some E such that Z ≡ ±Rµ0
(mod n). Thus,
1 (mod p′q′). This implies that
we have RE
E = ejµ′
1 must hold over the integers as we could factor n otherwise. Therefore ej is indeed a factor of E
as claimed.

(mod n) from which we can conclude that E ≡ e1µ′

1 A′εSν′

0 (Rej

1A′εSν′

1 = R

0 RE

1 )µ′

ej µ′
1

1

It is not hard to see that one can extend this proof to show that several attributes are encoded, e.g., that

ei, ej, and el are contained in E all at once:

1) :

PK{(ε, ν′, µ0, µ′
)µ′
Z ≡ ±Rµ0
µ0 ∈ ±{0, 1}ℓm ∧ µ′
ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

0 (Reiej el

1

1A′εSν′
(mod n) ∧
1 ∈ ±{0, 1}ℓm−3ℓt ∧

In other words, we have just shown how to very efﬁciently implement an AND statement over the

attributes.

Showing that an attribute is not contained in E, i.e., how to prove a NOT-relation

Now, proving that a given ej is not contained in her credential amounts to show that ej ∤ E is the case] The
user can do so by showing that there exist two integers a and b such that aE + bej = 1. Note that a and b do
not exist if ej | E. Also note that a and b can be computed efﬁciently with the extended Euclidian algorithm.

The protocol that achieves this is as follows:
After having computed a and b, the user chooses a sufﬁciently large random r (about 80 bits larger n)
and computes a commitment D = gEhr mod n. She sends D to the veriﬁer and runs the following protocol
with him (where a and b are the secret denoted by α and β, respectively). Finally, the user engages with the
veriﬁer in the proof:

PK{(ε, ν′, µ0, µ1, α, β, ρ, ρ′) :

0 Rµ1

1 A′εSν′

Z ≡ ±Rµ0
D ≡ ±gµ1hρ mod n ∧ g ≡ ±Dα(gej )βhρ′
µ0, µ1 ∈ ±{0, 1}ℓm ∧ ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

(mod n) ∧

mod n ∧

8

Theorem 4.2. If a prover is successful in the above protocol, then she was issued a credential that does not
contain the attribute encoded by ej.

Proof. As before, it is standard to show that there exists a knowledge extractor who can extract from a
convincing prover values ε, ν′, µ0, µ1 ρ, α, β, ρ′ such that the equations given in the proof speciﬁcation
hold. Let us see what one can derive from these equations. First consider D ≡ ±gµ1hρ mod n and g ≡
±Dα(gej )βhρ′
mod n holds. Unless the
prover can compute logg h or a multiple of the order of g it must hold that 1 = µ1α + ejβ. Now, it is well
known that α and β can only exist if ej and µ1 are co-prime and thus ej | µ1. Because of the ﬁrst equation
of the proof speciﬁcation, we know that µ1 is contained in the CL signature and thus we can conclude that
the ej is not one of the attributes encoded in µ1, i.e., in the credential the user proves knowledge of.

mod n from which we can derive that g ≡ ±gµ1αhρα(gej )βhρ′

Obviously the protocol can be extended to show several attribute values are not contained in a credential

in just one proof by replacing ej by the product of the respective primes.

Showing that one of of a list if attributes is contained in a credential (OR-relation)

Let us now show how we can implement a proof of a statement such as I’m either a student, a retiree, or
unemployed as might be the case if one would be eligible for a reduce entrance fee to a museum. More
generally, we assume that we are given a list of encodings {e1, ...., eℓ} of attribute values (possibly ranging
over different attributes), for some ℓ. The idea we use here is that if a credential contains an attribute e that
is contained in this list, then there exists an integer a such that ae = Qℓ
i ei; if e is not in the list, then no such
integer a as e does not divide the product. Let us ﬁrst assume that the issuer imposes that only one attribute
gets encoded into a signed message. We will later see how we can extend this to several attributes.

To prove that her credential contains one of the attributes values {e1, ...., eℓ}, a user can employ the
following protocol. First, the user computes a commitment D to the attribute contained in her credential (in
the same way as for the other protocols), sends it to the veriﬁer, and then runs with the veriﬁer the following
proof protocol:

PK{(ε, ν′, µ0, µ1, α, ρ, ρ′) :
1 A′εSν′

0 Rµ1

mod n ∧

Z ≡ ±Rµ0
D ≡ ±gµ1hρ mod n ∧ gQℓ
µ0, µ1 ∈ ±{0, 1}ℓm ∧ ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

i ei ≡ ±Dαhρ′

(mod n) ∧

We leave the proof for this protocol to the reader and extend it to work also in case more than one
attribute is encoded into a signed message. So now, the goal is to show that one of the attribute values
encoded in the credential is contained in the list {e1, ...., eℓ}. The idea here is that the user commits to that
attribute value and then shows that it divides the protocol of the attribute values on the list as well as the
message encoded in the credential. However, we must take some special care as this statement also holds
for ±1 and so we must make sure that the commitment does not contain ±1. To this end we need to employ
of further group, i.e., one of prime order q and two generators g and h of that group such that logh g is
unknown. Now, except the commitment D to the attribute value in question, say ej, as before, the user
further computes the commitment D = gej hr, where r is a random element from Zq. Finally, the following

9

proof protocol will achieve our goal:

PK{(ε, ν′, µ0, µ1, α, β, δ, ρ, ρ′, ϕ, γ, ψ, ξ, σ) :

0 Rµ1

1 A′εSν′

(mod n) ∧ D ≡ ±gαhρ mod n ∧

Z ≡ ±Rµ0
gQℓ

i ei ≡ ±Dδhρ′

mod n ∧ 1 ≡ ±Dβgµ1hρ′

mod n ∧

D = gαhϕ ∧ g = (

D

g

)γhψ ∧ g = (gD)σhξ ∧

µ0, µ1 ∈ ±{0, 1}ℓm ∧ ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

Theorem 4.3. A user who can successfully run the protocol above must have been issued a credential that
encodes at least one of the attribute values {e1, ...., eℓ}.
Proof. Again, one can extract from a successful prover values (ε, ν′, µ0, µ1, ρ, α, β, ρ, ρ′, ϕ, γ, ψ, ξ, σ) such
that all the equations given in the proof protocol speciﬁcation hold. Let us consider what we can derive
from these equations. First, consider the equations D = gαhϕ and g = ( D
g )γhψ. Assuming the hardness of
computing logg h, we have 1 ≡ γ(α−1) (mod q) from which we can derive that α 6≡ 1 (mod q). A similar
argument can be made with g = (gD)σhξ regarding the statement α 6≡ −1 (mod q) and hence α 6= ±1
will also hold over the integers. Now consider D ≡ ±gαhρ mod n and gQℓ
mod n. Assuming
the hardness of factoring, we can conclude from these that α | Qℓ
i ei and thus that α equals one of the ei’s or
a product of them (as we know that α 6= ±1). Now, from the equation 1 = Dβgµ1hρ′
mod n we can derive
1 A′εSν′
that βα = µ1 holds over the integers provided factoring is hard. As we thus have Z ≡ ±Rµ0
(mod n) it follows that α is encoded in the credential and there for that at least one of the attribute value
encodings {e1, ...., eℓ} is contained in the credential issued to the prover.

i ei = Dδhρ′

0 Rβα

4.5 Prime Encodings For Other Schemes

We have presented how one can encode attributes efﬁciently for the RSA-based CL credential system. Our
method is intrinsically based on integer factorization and to be able to proves multiplicative relations among
committed values over the integers. The only known efﬁcient commitment scheme that works for the lat-
ter is the one by Damg˚ard, Fujisaki, Okamoto, which relies on the Strong RSA assumption. Thus, our
method works naturally with anonymity-providing schemes that themselves are based on the Strong RSA
assumption (e.g., [3, 36]) and indeed we made use of the fact that these scheme basically have the Damg˚ard-
Fujisaki-Okamoto built into them.

Nevertheless, our method can also be applied to other anonymity-providing schemes but requires one to
add the Strong RSA assumption to the list of assumption the scheme is based upon, as we rely on the integer
commitment scheme for proving the relations. Let us have sketch how this would be done. First, the scheme
needs to be capable to encode attributes as exponents (most efﬁcient scheme allow for that, e.g., [4, 7, 16]).
However, such encoding is usually done in the exponent of a group where the prover knows the order, say
q, and therefore all relations that can be proven about values contained in the credential hold modulo q
only. Therefore, the prover needs to provide an integer commitment to the attribute values contained in
the credential (i.e., the product of the prime encoded attribute values), so that we can do our proofs for the
prime encodings over the integers. Of course, the prover needs to prove that the very same value contained
in the commitment is also encoded in the credential. Here one must apply some care to avoid that the prover
cannot add a multiple of q to the committed value, i.e., the prover needs to prove that the commitment
contains a value between 0 and q which we can do using the range proof by [5] at the cost of about 5 extra
commitments and 5 proof-terms.

10

5 Efﬁciency

Our improved credential system encodes a large set of binary and ﬁnite set attributes without signiﬁcant
performance impacts. The computational complexity of a traditional CL proof of possession is linear in the
total number of attributes, whereas our system’s complexity only depends on the number of string/integer
attributes. Binary and ﬁnite-set attributes are essentially for free. Even though the number of binary/ﬁnite-
set attributes has a inﬂuence on the performance, we can consider it as constant for all practical purposes2.
Both schemes have identical complexity if credentials only contain string or integer attributes, as soon as
binary or ﬁnite-set attributes are involved the prime encoding scheme achieves superior efﬁciency.

5.1 Measurement Method

Our key goal is to improve the efﬁciency of the CL signature scheme on small devices, particularly on
smartcards. We encountered the following three properties during the evaluation of smartcard capabilities:
(1) Most smartcards do not provide a hardware primitive for multi-base exponentiation. One either needs
to resort to a software implementation or the hardware’s modular exponentiation. (2) Partially, the cards
do not provide sufﬁcient access to the square and multiply primitives, which hinders an efﬁcient software
implementation of multi-base exponentiations. (3) Partially, the cards have severe transient memory re-
strictions, which hamper a multi-base exponentiation in one go. A software implementation can therefore
experience a negative performance impact. We conclude, that we cannot restrict our efﬁciency measurement
to multi-base exponentiations, but need to examine modular exponentiations.

How to compute the number of exponentiations from a Camenisch-Stadler [18] term of a CL
Signature(A, e, v)? First, the prover computes a blinded CL signature (A′, e, v′), which amounts to one
exponentiation:

A′ := ASv∗ for v∗ ∈R {0, 1}ℓv

Second, the prover facilitates the following proof of knowledge:

PK{(ε, ν′, µ0, µ1, µ2) :
1 Rµ2

0 Rµ1

2 A′εSν′

Z ≡ ±Rµ0
µ0 ∈ ±{0, 1}ℓm ∧ µi ∈ ±{0, 1}ℓm−3ℓt ∧
ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

(mod n)

[18] deﬁne how to transform such a statement in a Schnorr proof. The prover choses random values rε, rν′,
rµ0, rµ1, rµ2 from {0, 1}ℓ· for each proven value. ℓ· represents length parameter of the system speciﬁcation
corresponding to this randomness. The prover computes a commitment

T = A′rεR

rµ0
0 R

rµ1
1 R

rµ2
2 Srν′

(mod n).

This involves either one multi-base exponentiation or modular exponentiations in the number of attributes
plus two. For a given challenge c, the prover computes response values sε, sν′, sµ0, sµ1, and sµ2 as follows:

sε = rε + cε;

sν′ = rν′ + cν′;

sµ1 = rµ1 + cµ1;

sµ2 = rµ2 + cµ2

2Our system uses prime exponents with a very short bit-length and treats them in a single exponentiation. This single expo-
nentiation becomes costly for a large prime product E = Q1≤i≤ℓ
E) multiplications. If one restricts
the bitlength of E to the standard message length parameter of Identity Mixer (ℓm = 256) one can handle 37 binary attribute
realizations with the same complexity as one single exponentiation for a string/integer attribute. See Appendix Section B.

ej , as it requires O(log2

11

Thus, in total we have number of attributes plus three exponentiations. We observe that the number of
exponents in the Camenisch-Stadler notation determines the number of exponentiations in the corresponding
zero-knowledge proofs.

How to treat partially disclosed attributes? In our prime encoding scheme, we create proofs over known

prime exponents, say ei and ej, proving knowledge of the remainder µ′

1 as follows:

PK{(ε, ν′, µ0, µ′
Z ≡ ±Rµ0

1) :

0 (Reiej

1

)µ′

1A′εSν′

(mod n) ∧ [. . .]}

We will count a term (Reiej
)µ′
1
from {0, 1}ℓm and then compute the product rµ1 = eiejrµ′
choose a random value rµ′
prover includes this randomness with only one exponentiation into the commitment T .

1 as one exponentiation because of the following rationale: The prover can
as randomness. The

1

1

5.2 Qualitative Analysis

Let us ﬁrst consider the differences of traditional encoding in credential systems and the prime encoding.
We do so by comparing different proof statements for a credential with only two ﬁnite-set attributes. We
focus on the computational workload of the prover, as small devices usually act in this role. In principle,
all proofs with the Camenisch-Lysyanskaya credential system are structured as follows: the user provides
a proof of possession of the credential ﬁrst, potentially disclosing certain attribute values. The prover may
commit to some attributes to facilitate further proofs (e.g., range). The proof of possession requires one term
and exponentiations linear of the number of attribute bases3:

PK{(ε, ν′, µ0, µ1, µ2) :
1 Rµ2

0 Rµ1

2 A′εSν′

Z ≡ ±Rµ0
µ0 ∈ ±{0, 1}ℓm ∧ µi ∈ ±{0, 1}ℓm−3ℓt ∧
ε ∈ [2ℓe−1 + 1, 2ℓe − 1]}

(mod n) ∧

This sets the baseline of complexity for all subsequent proofs with the credential system. Subsequently, we
omit the ranges of the attribute messages and exponents for readability (denoted by [. . .]).

5.2.1 AND-Proof

Let us consider an example where a user wants to prove her expertise according to the ACM Computing
Classiﬁcation Scheme [2]: E.Data ∧ D.SW. We refer to Appendix Section C for such an application
example. An AND-proof with the traditional encoding in the CL-signature uses one exponentiation for each
attribute base. The prover facilitates the following proof of knowledge with a selective disclosure of the
attribute values E.Data and D.SW:

PK{(ε, ν′, µ0) :
Z ≡ ±Rµ0

0 RE.Data

1

RD.SW

2

A′εSν′

(mod n) ∧ [. . .]}

Proving knowledge of several prime-encoded attribute does not produce any overhead. The required
attributes are encoded in one attribute base and their conjunctive selective disclosure can be implemented

3To be precise: L + 2 exponentiations for the attributes including the secret key plus one exponentiation for the blinding

12

with one modular exponentiation. This realizes a AND-proof in a constant number of exponentiations.

PK{(ε, ν′, µ0, µ′
Z ≡ ±Rµ0

1) :

0 (Reiej

1

)µ′

1A′εSν′

(mod n) ∧ [. . .]}

5.2.2 NOT-Proofs

The NOT-proof methods of the traditional approach and the prime-encoding are very similar. Both methods
require a commitment to the relevant attribute and a linear relationship proof. For the traditional approach
the proof is constructed as follows:

PK{(ε, ν′, µ0, µ1, µ2, α, β, ρ) :
2 A′εSν′

1 Rµ2

0 Rµ1

Z ≡ ±Rµ0
D ≡ ±gµ1hρ mod n ∧ g ≡ ±(D/gρ)αhβ ∧ [. . .]}

(mod n) ∧

The NOT-proof of the new system needs to take the structure of the dedicated prime attribute into
account, however, does not differ conceptually from the traditional approach. Given that we count (gej )β as
one exponentiation, both methods have the same complexity:

PK{(ε, ν′, µ0, µ1, α, β, ρ, ρ′) :

0 Rµ1

1 A′εSν′
Z ≡ ±Rµ0
D ≡ ±gµ1hρ mod n ∧
g ≡ ±Dα(gej )βhρ′

(mod n) ∧

mod n ∧ [. . .]}

5.2.3 OR-Proofs

We use an example where a user proves that either the attribute social beneﬁt = social beneﬁt or the
attribute profession = student. We elaborate on such a case in the environment of electronic identity
cards in Section 6.2. The traditional approach needs to produce an overhead proportional to the number
of relevant attributes as well as to the number of comparison alternatives. The system ﬁrst commits to the
relevant attribute values, which means computing the commitment as well as proving knowledge of it:

PK{(ε, ν′, µ0, µ1, µ2, ρ, ρ′) :

1 Rµ2

2 A′εSν′
(mod n) ∧

0 Rµ1
Z ≡ ±Rµ0
D1 ≡ ±gµ1hρ
D2 ≡ ±gµ2hρ′

(mod n) ∧ [. . .]}

(mod n) ∧

It then facilitates proofs of knowledge over the committed attribute values, in this case a disjunction of
equality proofs. If the user intends to prove that her attribute is one out of ten variants, she needs to provide
ten equality proofs similar to those:

PK{(ρ, ρ′) :

D1/gsocial beneﬁt ≡ ±hρ
D2/gstudent ≡ ±hρ′

(mod n)}

(mod n) ∨

13

Number of bases

l + k

Proof of possession

l + k + 4 E.

Knowledge of 1
binary attr.

AND of i
binary attr.

NOT of 1
binary attr.

OR of i
binary attr.

1 M.
l + k + 4 E.

1 M.
l + k + 4 E.

4 M.
l + k + 11 E.

O(L)

O(L)

O(1)
O(L)

O(1)
O(L)

O(1)
O(L)

l + 1

l + 5 E.

1 + 2k + 2 M.
l + 4k + 7 E.

O(l)

O(l)

O(k)
O(L)

2k + i + 2 M.
l + 4k + i + 7 E. O(L + i)

O(2i)

Prime Encoding
absolute

asymp.

l + 1

l + 5 E.

1 M.
l + 5 E.

1 M.
l + 5 E.

O(l)

O(l)

O(1)
O(l)

O(1)
O(l)

2k + 4 M.
l + 4k + 10 E.

O(k)
O(L)

O(1)
4 M.
l + 13 E. O(l)

Parameter

Base Encoding

Bit-Vector Encoding

absolute

asymp.

absolute

asymp.

3i + 1 M.
l + k + 6i + 4 E. O(L + i)

O(i)

2k + 3i + 1 M.
O(k + i)
l + 3k + i + 7 E. O(L + i)

O(1)
9 M.
l + 23 E. O(l)

Table 1: Computational Complexity. Gray color denotes best result. Notation: M. are multi-base exponen-
tiations, E. modular exponentiations. L is the total number of attribute bases without secret key. l is the
number of string/integer attributes, whereas k: number of prime-encodable attributes/value set for multi-
variate ﬁnite-set attributes. i is the number of attributes referenced in a proof.

Our new method also facilitates the OR-proof in a constant number of exponentiations. It involves (1)
committing to the dedicated prime attribute Rµ1
1 in the ﬁrst line of the proof statement, (2) showing that the
user’s attribute value is contained in the list of options and that it divides the credential message (second
line), and (3) proving that the commitment is free from ±1 (two last lines):

PK{(ε, ν′, µ0, µ1, α, β, δ, ρ, ρ′, ϕ, γ, ψ, ξ, σ) :

(mod n) ∧

0 Rµ1

1 A′εSν′
Z ≡ ±Rµ0
D ≡ ±gαhρ mod n ∧
gQℓ
D = gαhϕ ∧

i ei ≡ ±Dδhρ′

mod n ∧ 1 ≡ ±Dβgµ1hρ′

mod n ∧

g = (

D

g

)γhψ ∧ g = (gD)σhξ ∧ [. . .]}

This construction requires two commitments (computing the commitments and proving their knowledge)
and four linear relationship proofs in total. The number of terms and exponentiations is essentially indepen-
dent from the number of OR-Terms. We note that prime exponents are publicly known and very small, thus,
gQℓ
i ei counts as one exponentiation for all practical purposes. Thus, we account for a constant overhead of
23 exponentiations over a normal proof of possession.

5.3 Quantitative Analysis

We compare the computational complexity between the Camenisch-Lysyanskaya system, a bit-vector en-
coding, and our method in Table 1. We count the number of multi-base exponentiations and the number of
modular exponentiations.

The comparison is based on the following parameters:

• L: total number of attribute bases without secret key,

14

• l: number of string/integer attributes,

• k: number of prime-encodable attributes/value set for multi-variate ﬁnite-set attributes,

• i: number of attributes referenced in a proof.

We notice that in general the proofs of possessions of CL credentials are impacted by the total number of
attribute bases L, whereas the bit-vector and prime encoding only depend on the number of string/integer
attributes l. For simple attribute proofs, CL and bit-vector encoding require O(L) exponentiations whereas
our system only depends on the number of string/integer attributes O(l). If one considers a credential with
only binary or ﬁnite-set attribute, CL and bit-vector encoding have a complexity of O(L), whereas our
system runs in constant time O(1). The AND proofs are impacted by the total number of attributes and
require O(L) exponentiations. Once the proof of possession is complemented by an OR-statement, CL
encoding requires O(i) terms and O(L + i) exponentiations4. A traditional bit-vector encoding as discussed
in Section 4.1 involves bit-commitments to all encoded attributes (two exp. for computing, two for proving),
bitwise OR-proofs for all attributes (two exp.), and one equality proof over their product (two exp.). This
amounts to O(k + i) terms and O(L + i) exponentiations. Our system allows for proofs with a constant
term number. The total number of prime-encodable attributes k does not impact the performance at all. This
comes at a cost of a constant overhead of 18 exponentiations. We discuss the structures of the AND/OR
proof statements in Sections 5.2.1 and 5.2.3.

To stress our point, we make an experiment with the number of prime-encodable attributes being large
against the number of string/integer attributes: k ≫ l. Say we only encode a huge number of binary
or ﬁnite-set attributes (L = k ≫ i). In this case the results are as follows: then proof statements with
CL and bit-vector encoding will converge to O(L) exponentiations. Our system, however, converges to a
constant number of terms and exponentiations O(1). Note that the bitlength of the prime product exponent
E impacts the complexity of this single exponentiation, as it requires O(log2 E) multiplications. For all
practical applications it is negligible5.

6 Applications

6.1 Requirements

An application of our extension to the CL credential system needs to fulﬁll two requirements: (1) a sufﬁcient
supply of prime-encodings and (2) a certiﬁed binding between prime-encoding and discrete values. First, we
observe that the number of primes below a certain number x is estimated by the prime number theorem as
outlined in [42] and converges to π(x) = x/ln(x). There exist, for instance, roughly 75.638 prime numbers
smaller than 20 bits. This is a plentiful supply for most application scenarios. Second, the issuer needs
to sign the binding between primes and discrete values in its public key. Thus, the binary/discrete values
used by the credential system are static. This excludes highly dynamic applications with ad-hoc issuing of
credentials with new attribute types, however, does not impact any of the standard application scenarios for
credential systems. Typical organizations issuing credentials are governments, banks, mobile operators, etc.
Their vocabulary for binary/ﬁnite-set attributes is standardized well in advance.

We observe that space constraints impact the number of ﬁnite set attributes the system can govern. The
size of the attribute exponent in the user’s credential limits the number of prime ﬂags set in a credential. We

4Per i we have two exp. to compute the commitment, two to prove its knowledge, and two to prove equality.
5We show in Appendix Section B, that one can encode 37 attribute realizations in a standard-size message exponent of

Camenisch-Lysyanskaya.

15

elaborate on this fact in Appendix Section B. The size of the issuer’s public key limits the total number of
attribute realizations certiﬁed for the system. Thus, even if many sets in real world are inherently ﬁnite, a
system needs to balance between efﬁciency gain and and space consumption.

The proposed credential system is particularly suited for multiple classes of attributes:

Binary: The attribute can either be present or not, true or false, e.g., being a civil servant.

Finite Set: A ﬁnite set of discrete attribute values, where a user may realize at most one potential value.

E.g., hair color.

Multi-Variate Finite Set: A ﬁnite set of discrete attribute values, where a user may realize any subset of

values. A user may hold multiple values for an attribute such as profession.

Finite Data Structures: Complex data structures of discrete values from a ﬁnite set, where trees are most
useful: a user may realize a sub-tree or path of a super-tree predetermined by the issuer. Examples for
such attributes are expertise or health taxonomies as well as role hierarchies.

These attribute types impact a large variance of application scenarios. We choose electronic identity cards
as primary example and complement that with complex expertise as well as medical credentials in the
Appendix C.

6.2 Examples for Electronic Identity Cards

Currently, different European countries are issuing different variants for electronic identity cards (EID).
The computational restrictions of such smartcards are obvious. The desire for protection of citizen rights
by privacy-enabling technologies is also a recurring topic. Particularly, in the area of secondary use—that
is, when a third party is accessing the user’s data—privacy concerns surface quickly. In early proposals,
arbitrary third parties could access the full data set about the user.

We surveyed different data sets for EID and driver’s license cards and use the Belgium EID card as
example [41]. Table 2 outlines a superset of example attributes, where the left column contains string and
integer attributes, whereas the right column contains attributes encodable by our prime representation. We
explicitly mention minority status as, for instance, the Belgium EID card speciﬁcation [41, pp.12] explicitly
covers this option6.

We tailored our scheme to attributes that have a ﬁnite set of values. The user may realize a multi-valued
subset. Minority status, profession, or academic degree are such attributes. A citizen may, for instance, be
a doctor as well as a civil servant. Traditional CL signatures encodes each attribute in a separate attribute
base, for multi-variate attributes from ﬁnite set it even needs to encode each potential realization in a base.
For the attributes in Table 2, this results in 23 attribute bases.7

With our prime encoding we can fold all binary and ﬁnite-set attributes into one attribute base. We
choose a prime ei for all binary attributes and ﬁnite set attribute realizations in Table 2: this involves 193
possible realizations of nationality, 429 realizations of place of issuance districts, 6400 districts for place of

6Application of such an attribute varies much from country to country. For instance, Belgium encodes a status for blind and
for the visually impaired citizens. The German driver’s license also encodes the requirement to wear glasses. Further attributes for
deaf or hearing-impaired citizens are thinkable. Though countries also envision attributes such as profession (e.g., doctor) or role
as civil servant, their storage on the EID card itself is currently subject to much dispute.

7Nationality and place of issuance will be encoded by a index number. We assume the minority and social beneﬁt status as
multi-variate attributes with seven realizations spread over ﬁve attributes. For the potentially multi-variate attributes profession and
academic degree we reserve ﬁve attributes in total. The number of attribute bases is therefore 23 and L = 24.

16

String/Integer

Binary/Finite Set

Example Values

1) name
2) ﬁrst name
3) date of birth
4) identiﬁcation number
5) date of issuance

6) sex
7) nationality
8) place of birth
9) type of card
10) place of issuance
11) validity time
12-13) eye and hair color
14-16) minority status

{male, female}
193 recognized states
6400 villages and cities (e.g., Germany)
{EID, kids card}
429 districts (e.g., Germany)
{2 year, 5 year, 10 year}
6 hair colors, 8 eye colors
{blind, vis impaired, deaf,

17-18) social beneﬁt status
19-21) profession
22-23) academic degree

hear impaired, phys impaired}
{none, unemployed, social beneﬁt}
{student, teacher, civil servant, doctor, . . . }
{B.S., M.S., Ph.D., M.D., . . . }

Table 2: Potential attributes on electronic identity cards.

Parameter

CL

Prime

Number of attribute bases
E. proof of possession

M. in AND-proof for PEID,OP
E. in AND-proof for PEID,OP

M. in OR-proof for PEID,CS
E. in OR-proof for PEID,CS

23
27

1
27

28
67

6
10

1
10

9
28

Table 3: Complexity in EID Scenario: PEID,CS – CL requires nine commitments and eleven equality proofs;
prime encoding contents itself two commitments and four relationship proofs. PEID,OP – CL requires and
AND proof over all L attributes, whereas the prime encoding is only impacted by the l string/integer at-
tributes.

birth as well as several hundred professions, and 14 color variations for hair and eyes. We dedicate the ﬁrst
attribute base, for the product of the corresponding prime numbers ej that the user realizes. We are left with
ﬁve normal attribute bases and one attribute base R1 for the prime encoding. Thus, the number of bases is
already one fourth and all proofs of possessions speed up by factor four.

Opinion Polls

An often discussed example is online opinion polls. In this scenario, a user proves that she belongs to a
certain statistical class while retaining a suitable anonymity set. Opinion polls usually gather demographic
data, but may also collect educational and professional parameters. We leave the range proof for the date of
birth aside, as it is equally costly for both methods.8 The remaining proof may be constructed according to
a conjunctive selective disclosure as speciﬁed in policy PEID,OP:

sex = female ∧ nationality = French ∧

place of birth = Paris ∧ social beneﬁt = none ∧

profession 1 = doctor ∧ profession 2 = civil servant ∧

ac degree 1 = M.D. ∧ ac degree 2 = Ph.D.

8Of course, there is also a very efﬁcient method for coarse-grained range proofs leveraging the prime encoding. We do not use

it for this comparison.

17

We discussed this general proof structure in Section 5.2.1. A traditional approach requires a proof of
possession over L attribute bases9. We outline in Table 3 that our new system facilitates the proof without
any overhead to the proof of possession. It is therefore only impacted by the l string/integer attributes. It is
three times as efﬁcient, even though we only safe the k attribute bases for the prime-encoded attributes.

Cultural Subsidies

Virtually all countries grant subsidies for access to cultural institutions to particular population groups: chil-
dren, students, seniors as well as handicapped persons and persons eligible for social beneﬁts. Partially,
the corresponding groups show hesitation to disclose their special status because of privacy concerns. Pol-
icy PEID,CS is depicts a disjunction proof over attributes from Table 2:

Wminority (blind, vis impaired, deaf, . . .) ∨
Wsocial beneﬁt (unemployed, social beneﬁt) ∨
Wprofession (student, teacher, civil servant) ∨

(type = kids card)

As demonstrated in Section 5.2.3, this amounts to a proof of possession, attribute commitment to all
relevant attributes (nine terms)10, and a second step disjunction of equality proofs for the possible attribute
values (eleven terms). Our new scheme reduces the effort to a single multi-element OR-proof in the prime
encoding. As shown in Section 4.4, the user needs to provide a proof of possession with four terms, a
commitment to the prime attribute base and proofs of their knowledge and division (three terms) as well as
proofs that the commitment does not contain ±1 in a second group (three terms). We compare both methods
in Table 3 and observe that our new method is three times as efﬁcient for all proofs of possessions as well
as the OR-proof for policy PEID,CS.

6.3 Discussion

Our method is a enabler for credential systems on small devices. Until now, application designers for this
area restricted themselves to simple scenarios: credentials must only govern a minimal number of attributes,
proof statements must be as simple as possible. The linear complexity in the total number of attributes for
the proofs of possession puts credential-enabled EID systems at peril. The vastly growing number of terms
and commitments, and thus computational and communication costs, for complex proof statements acted as
second bottleneck. These tremendous limitations rendered sensible applications on small devices virtually
impossible.

We have shown that our prime-encoding idea makes complex proofs in various application scenarios
possible. Be it beneﬁt access with a large anonymity set or collecting demographic data in a private manner
in the example of an electronic identity card; be it complex expertise taxonomies of a corporate card; or be it
structured diagnostic statements in a healthcare card—our system achieves tremendous performance boosts.
This does not only hold for the AND/OR example policies, but also for the overall reduction of attribute
bases. The latter parameter impacts every single proof. All these improvements bring applications barely
running in feasible time with traditional encodings well in reach of small devices.

9We leverage the system’s capability to have multiple values for the attribute profession and academic degree ac degree.
10Note that the attributes minority, social beneﬁt , and profession are spread over multiple attribute bases to account of multiple
realizations by a user. We assumed three for the minority, two for social beneﬁt , and three for profession, thus, nine terms in
total.

18

In addition to occupying a high ground in the quest for performance, the system comes with two subtle
advantages: (1) discrete and structured attributes, (2) signiﬁcant policy independence. First, we focus on
discrete values from ﬁnite sets. These may be as simple as binary ﬂags or complex data structures. In
contrast to an unstructured integer/string encoding, discrete values can be manipulated by equality and
relationship proofs. Their semantic is accessible to the credential system itself. Second, we observe that our
method requires a constant number of terms and commitments for pure equality, conjunction and disjunction
proofs with binary/ﬁnite-set attributes. Independent from the number of AND/OR clauses in the policy, the
proof only uses a ﬁxed low number of exponentiations. This makes a transaction and their expected response
time predictable to device producers.11

7 Conclusion

We presented an extension to the Camenisch-Lysyanskaya credential system. It features efﬁcient encoding
and proofs of binary and ﬁnite-set attributes. The idea to use coprime and divisibility properties in proofs
gains us strong performance improvements. We pay the price of certifying prime/attribute value relation-
ships in the issuer’s public key and win the ability to facilitate proofs of possession, equality, AND, NOT,
and OR proofs very efﬁciently. Our method overcomes the fundamental limitation of all existing credential
systems that their complexity is linear in the total number of attributes. It allows us to fold many ﬁnite set
attributes in a single attribute base and therefore boosts the performance of all proofs of possession. Our
new proof primitives on the prime-encoding facilitate AND, NOT, and OR statements with constant com-
plexity and minimal overhead to a standard proof of possession. Our method does not require additional
cryptographic assumptions apart from Strong-RSA.

Our method targets the major attribute classes of credential systems. In fact, we perceive that only a
minority of attributes requires a generic string or integer attribute (such as name and birthday), whereas
most attributes are either binary or taken from a ﬁnite set of discrete values. Those are the attributes which
applications need for logical statements. Emerging efforts to standardize vocabulary for identity federation
protocols in different application areas support our hypothesis. We demonstrated that our method impacts
real applications such as electronic identity cards or complex forms of professional and medical credentials.

Acknowledgement

The authors are grateful to the anonymous reviewers of this paper at ACM CCS. They provided valuable
and thorough feedback. We thank Saner Celebi for his careful review and comments.

The research leading to these results has received funding from the European Community’s Seventh

Framework Programme (FP7/ 2007-2013) under grant agreement n◦ 216483.

The information in this document is provided “as is”, and no guarantee or warranty is given that the
information is ﬁt for any particular purpose. The above referenced consortium members shall have no
liability for damages of any kind including without limitation direct, special, indirect, or consequential
damages that may result from the use of these materials subject to any liability which is mandatory due to
applicable law.

11In traditional encodings this is not the case. If a traditional CL system receives a policy from a service provider that requires
25 ﬁnite-set attributes and 100 OR-clauses, the system will facilitate 25 commitments and 100 equality proofs executing roughly
150 exponentiations. Our system would ﬁnish after 23 exponentiations independently from the policy. We stress that this holds for
pure conjunctions (only containing AND-clauses) and disjunctions (only containing OR-clauses). This situation is more diverse for
nested logical statements.

19

References

[1] American Psychiatric Association. Diagnostic and Statistical Manual of Mental Disorders (DSM-IV-
TR). American Psychiatric Publishing Inc., 1000 Wilson Boulevard, Suite 1825, Arlington, VA 22209,
fourth edition, text revision edition, 2000. ISBN 9780890420249.

[2] Association for Computing Machinery (ACM). ACM computing classiﬁcation system (CCS). http:

//oldwww.acm.org/class/1998/ccs98.html, 2007.

[3] Giuseppe Ateniese, Jan Camenisch, Marc Joye, and Gene Tsudik. A practical and provably se-
cure coalition-resistant group signature scheme. In Mihir Bellare, editor, Advances in Cryptology —
CRYPTO 2000, volume 1880 of Lecture Notes in Computer Science, pages 255–270. Springer Verlag,
2000.

[4] Dan Boneh, Xavier Boyen, and Hovav Shacham. Short group signatures. In Matthew K. Franklin,
editor, Advances in Cryptology — CRYPTO 2004, volume 3152 of Lecture Notes in Computer Science,
pages 41–55. Springer Verlag, 2004.

[5] Fabrice Boudot. Efﬁcient proofs that a committed number lies in an interval. In Bart Preneel, editor,
Advances in Cryptology — EUROCRYPT 2000, volume 1807 of Lecture Notes in Computer Science,
pages 431–444. Springer Verlag, 2000.

[6] Stefan Brands. An efﬁcient off-line electronic cash system based on the representation problem. Tech-

nical Report CS-R9323, CWI, April 1993.

[7] Stefan Brands. Restrictive blinding of secret-key certiﬁcates. Technical Report CS-R9509, CWI,

September 1995.

[8] Stefan Brands. Secret-key certiﬁcates. Technical Report CS-R9510, CWI, September 1995.

[9] Stefan Brands. Rapid demonstration of linear relations connected by boolean operators. In Walter
Fumy, editor, Advances in Cryptology — EUROCRYPT ’97, volume 1233 of Lecture Notes in Com-
puter Science, pages 318–333. Springer Verlag, 1997.

[10] Stefan Brands. Rethinking Public Key Infrastructure and Digital Certiﬁcates— Building in Privacy.

PhD thesis, Eindhoven Institute of Technology, Eindhoven, The Netherlands, 1999.

[11] Jan Camenisch, Susan Hohenberger, Markulf Kohlweiss, Anna Lysyanskaya, and Mira Meyerovich.
How to win the clonewars: efﬁcient periodic n-times anonymous authentication.
In Ari Juels, Re-
becca N. Wright, and Sabrina De Capitani di Vimercati, editors, ACM Conference on Computer and
Communications Security, pages 201–210. ACM, 2006.

[12] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact E-cash. In Ronald Cramer,
editor, Advances in Cryptology — Eurocrypt 2005, volume 3494 of Lecture Notes in Computer Science,
pages 302–321. Springer, 2005.

[13] Jan Camenisch and Anna Lysyanskaya. Efﬁcient non-transferable anonymous multi-show credential
system with optional anonymity revocation. In Birgit Pﬁtzmann, editor, Advances in Cryptology —
EUROCRYPT 2001, volume 2045 of Lecture Notes in Computer Science, pages 93–118. Springer
Verlag, 2001.

20

[14] Jan Camenisch and Anna Lysyanskaya. Dynamic accumulators and application to efﬁcient revocation
of anonymous credentials. In Moti Yung, editor, Advances in Cryptology — CRYPTO 2002, volume
2442 of Lecture Notes in Computer Science, pages 61–76. Springer Verlag, 2002.

[15] Jan Camenisch and Anna Lysyanskaya. A signature scheme with efﬁcient protocols. In Stelvio Cimato,
Clemente Galdi, and Giuseppe Persiano, editors, Security in Communication Networks, Third Inter-
national Conference, SCN 2002, volume 2576 of Lecture Notes in Computer Science, pages 268–289.
Springer Verlag, 2003.

[16] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear
maps. In Matthew K. Franklin, editor, Advances in Cryptology — CRYPTO 2004, volume 3152 of
Lecture Notes in Computer Science, pages 56–72. Springer Verlag, 2004.

[17] Jan Camenisch and Markus Michels. Proving in zero-knowledge that a number n is the product of two
safe primes. In Jacques Stern, editor, Advances in Cryptology — EUROCRYPT ’99, volume 1592 of
Lecture Notes in Computer Science, pages 107–122. Springer Verlag, 1999.

[18] Jan Camenisch and Markus Stadler. Efﬁcient group signature schemes for large groups.

In Burt
Kaliski, editor, Advances in Cryptology — CRYPTO ’97, volume 1296 of Lecture Notes in Computer
Science, pages 410–424. Springer Verlag, 1997.

[19] Jan Leonhard Camenisch. Group Signature Schemes and Payment Systems Based on the Discrete
Logarithm Problem. PhD thesis, ETH Z¨urich, 1998. Diss. ETH No. 12520, Hartung Gorre Verlag,
Konstanz.

[20] Agnes Chan, Yair Frankel, and Yiannis Tsiounis. Easy come – easy go divisible cash. In Kaisa Nyberg,
editor, Advances in Cryptology — EUROCRYPT ’98, volume 1403 of Lecture Notes in Computer
Science, pages 561–575. Springer Verlag, 1998.

[21] David Chaum. Untraceable electronic mail, return addresses, and digital pseudonyms. Communica-

tions of the ACM, 24(2):84–88, February 1981.

[22] David Chaum. Blind signatures for untraceable payments. In David Chaum, Ronald L. Rivest, and
Alan T. Sherman, editors, Advances in Cryptology — Proceedings of CRYPTO ’82, pages 199–203.
Plenum Press, 1983.

[23] David Chaum. Security without identiﬁcation: Transaction systems to make big brother obsolete.

Communications of the ACM, 28(10):1030–1044, October 1985.

[24] David Chaum and Jan-Hendrik Evertse. A secure and privacy-protecting protocol for transmitting per-
sonal information between organizations. In M. Odlyzko, editor, Advances in Cryptology — CRYPTO
’86, volume 263 of Lecture Notes in Computer Science, pages 118–167. Springer-Verlag, 1987.

[25] David Chaum and Torben Pryds Pedersen. Wallet databases with observers.

In Ernest F. Brickell,
editor, Advances in Cryptology — CRYPTO ’92, volume 740 of Lecture Notes in Computer Science,
pages 89–105. Springer-Verlag, 1993.

[26] David Chaum and Eug`ene van Heyst. Group signatures. In Donald W. Davies, editor, Advances in
Cryptology — EUROCRYPT ’91, volume 547 of Lecture Notes in Computer Science, pages 257–265.
Springer-Verlag, 1991.

21

[27] Ronald Cramer, Ivan Damg˚ard, and Berry Schoenmakers. Proofs of partial knowledge and simpliﬁed
design of witness hiding protocols. In Yvo G. Desmedt, editor, Advances in Cryptology — CRYPTO
’94, volume 839 of Lecture Notes in Computer Science, pages 174–187. Springer Verlag, 1994.

[28] Ivan Damg˚ard and Eiichiro Fujisaki. An integer commitment scheme based on groups with hidden

order. http://eprint.iacr.org/2001, 2001.

[29] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identiﬁcation and signature
problems. In Andrew M. Odlyzko, editor, Advances in Cryptology — CRYPTO ’86, volume 263 of
Lecture Notes in Computer Science, pages 186–194. Springer Verlag, 1987.

[30] Yair Frankel, Yiannis Tsiounis, and Moti Yung. Fair off-line e-cash made easy. In Kwangjo Kim and
Tsutomu Matsumoto, editors, Advances in Cryptology — ASIACRYPT ’98, volume 1514 of Lecture
Notes in Computer Science, pages 257–270. Springer Verlag, 1998.

[31] Atsushi Fujioka, Tatsuaki Okamoto, and Kazuo Ohta. A practical secret voting scheme for large scale
elections. In Jennifer Seberry and Yuliang Zheng, editors, ASIACRYPT, volume 718 of Lecture Notes
in Computer Science, pages 244–251. Springer, 1992.

[32] Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to prove modular poly-
nomial relations. In Burt Kaliski, editor, Advances in Cryptology — CRYPTO ’97, volume 1294 of
Lecture Notes in Computer Science, pages 16–30. Springer Verlag, 1997.

[33] Shaﬁ Goldwasser, Silvio Micali, and Ronald Rivest. A digital signature scheme secure against adaptive

chosen-message attacks. SIAM Journal on Computing, 17(2):281–308, April 1988.

[34] IBM. Cryptographic protocols of the Identity Mixer library, v. 1.0. IBM Research Report RZ3730,
IBM Research, 2009. http://domino.research.ibm.com/library/cyberdig.nsf/
index.html.

[35] Aggelos Kiayias and Moti Yung. Secure scalable group signature with dynamic joins and separable

authorities. IJSN, 1(1/2):24–45, 2006.

[36] Aggelos Kiayias, Moti Yung, and Yiannis Tsiounis. Traceable signatures. In Christian Cachin and Jan
Camenisch, editors, Advances in Cryptology — EUROCRYPT 2004, volume 3027 of Lecture Notes in
Computer Science, pages 571–589. Springer, 2004.

[37] Moni Naor, Benny Pinkas, and Reuben Sumner. Privacy preserving auctions and mechanism design.

In Proc. 1st ACM Conference on Electronic Commerce, 1999.

[38] Torben Pryds Pedersen. Non-interactive and information-theoretic secure veriﬁable secret sharing. In
Joan Feigenbaum, editor, Advances in Cryptology – CRYPTO ’91, volume 576 of Lecture Notes in
Computer Science, pages 129–140. Springer Verlag, 1992.

[39] Ronald L. Rivest, Adi Shamir, and Leonard Adleman. A method for obtaining digital signatures and

public-key cryptosystems. Communications of the ACM, 21(2):120–126, February 1978.

[40] Claus P. Schnorr. Efﬁcient signature generation for smart cards. Journal of Cryptology, 4(3):239–252,

1991.

22

[41] SPF Int´erieur. Instructions generales relatives `a la carte d’indentit´e ´electronique. SPF Int´erieur, Ser-
vice Registres de la Population et Cartes d’identit´e, Parc Atrium, rue des Colonies, 11, 1000 Bruxelles,
November 2005. http://www.registrenational.fgov.be.

[42] Eric W. Weisstein. Prime number theorem. From MathWorld–A Wolfram Web Resource. http:

//mathworld.wolfram.com/PrimeNumberTheorem.html, March 2008.

[43] Wikipedia. DSM-IV codes. http://en.wikipedia.org/wiki/DSM-IV_Codes, March

2008.

[44] World Health Organization (WHO). International Statistical Classiﬁcation of Diseases and Health
Related Problems (ICD-10). World Health Organization, Geneva, 2nd edition, 10th revision edition,
2005.

[45] World Health Organization

(WHO).

ICD-10

codes.

http://www.who.int/

classifications/apps/icd/icd10online, 2007.

APPENDIX

A Protocol Speciﬁcation

A.1 Parameters and Notation

We shortly name the main parameters of the Camenisch-Lysyanskaya signature scheme and refer to [34] for
a complete list.

• ℓn: Bitlength of the SRSA modulus n, for instance 2048 bits.

• ℓe: Bitlength of the e values of certiﬁcates, by default 596 bits.

• ℓ′

e: Size of the interval the e values are taken from, by default: 120 bits.

• ℓm: Bitlength of attributes, by default 256 bits.

• ℓv: Size of the v values of the certiﬁcates, by default 2723 bits.

• ℓø: Security parameter that governs the statistical zero-knowledge property, by default 80 bits.

We distinguish multiple index sets for attribute values:

• AKN: issuer-chosen or known attributes. Common input to both Issuer and Recipient.

• AE: known attributes encoded as prime numbers in the prime product exponent E. Common input to

both Issuer and Recipient.

• AUC: user-chosen attributes, only known to the Recipient.

Please note the we omit committed attributes for brevity, even though they compose easily with the prime
encoding. The Identity Mixer Speciﬁcation [34] deﬁnes their use.

23

A.2 Issuer Setup

Common input: Basic system parameters

See Identity Mixer Speciﬁcation [34].
skI = (p, q)
pkI = (n, S, Z, R1, . . . , Rl, P , (aj, ej)1≤j≤Λ, g, h, g, h)

Issuer output:
Public output:

Attribute Space

Issuer chooses a number of attribute bases ℓ.

Generation of a Safe RSA Key Pair

Issuer generates the safe primes p and q , p = 2p′ + 1 and q = 2q′ + 1, then computes n = pq . Consult
the Idemix Speciﬁcation [34] for suitable bitlength for n (ℓn bits), p and q (ℓn/2 bits).

Generation of CL Parameters

Issuer chooses

S ∈R QRn, and
Z, R1, . . . , Rl ∈R hSi

(where QRn is the group of quadratic residues mod n and hSi is the subgroup generated by S). S must
also have order #QRn = p′q′. The second step is done by choosing xZ, xR1, . . . , xRl ∈R [2, p′q′ − 1] and
computing Z = SxZ , Ri = SxRi for 1 ≤ i ≤ l.

Commitment Groups

Issuer generates bases g and h for integer commitments. It uses its RSA modulus n and chooses g and h as
elements of QRn. Issuer generates a prime-order group with order q and two generators g and h that logh g
is unknown.

Finite-Set Attributes

Issuer standardizes the set of binary and ﬁnite-set attributes: It enumerates all Λ possible attribute values aj.
It determines the the maximally possible attribute realization EMAX. Issuer chooses an odd prime number
ej for each attribute value aj.

Adjustment of System Parameters

Issuer determines the bitlength of EMAX and adjusts the required length for messages ℓm and e-value of the
CL-certiﬁcates ℓe.

24

Key Certiﬁcation

Issuer computes a non-interactive zero-knowledge proof of knowledge P , to prove that the public key
was generated correctly.12 Issuer signs the map of attribute value-prime pairs (aj, ej)1≤j≤Λ with the Fiat-
Shamir heuristic. It also signs the bases for the commitment groups. The proof P will convince a veriﬁer
that Z, Ri ∈ hSi for 1 ≤ i ≤ l and establish a binding between attribute values and prime encoding.

Key Output

Issuer’s public key is pkI = (n, S, Z, R1, . . . , Rl, P , (aj, ej)1≤j≤Λ, g, h, g, h) and the private key is skI =
(p, q) .

A.3 Issuing

Common input:

pkI , S (incl. ℓn, ℓe, ℓm, ℓø)), {mi}i∈AKN
where Sis the issue certiﬁcate speciﬁcation

, {(aj, ej)}j∈AE

Recipient private input: m1, {mk}k∈AUC , r
Issuer private input:
Recipient output:

skI
(A, e, v), m1, . . . , ml′, {(aj, ej)}j∈AE

, l′ ≤ l or ⊥

Round 0: Nonce

Issuer chooses a random nonce n1 ∈R {0, 1}ℓ∅ and sends it to the Recipient.

Round 1: User Commitment

1.1 Recipient chooses a random integer v′ ∈R ±{0, 1}ℓn+ℓ∅.

1.2 Recipient computes

U := Sv′

· X mod n

where X contains the user-chosen attributes:

X := Y
k∈AUC

Rmk

k mod n

Next, Recipient computes a non-interactive proof P1 that this was done correctly.

SPK {(cid:0)(mk)k∈AUC, v′(cid:1) :

(1)

U ≡ ±Sv′ Y

Rmk

k

(mod n) ∧

k∈AUC

mk ∈ ±{0, 1}ℓm+ℓ∅+ℓH +2 ∀ k ∈ AUC}

1.4 Recipient → Issuer: U , P1, n2 ∈R {0, 1}ℓ∅.

12We leave the detailed speciﬁcation of this proof to the Identity Mixer Speciﬁcation [34].

25

Round 2: Signature Generation

2.0 Issuer veriﬁes P1.

2.1 Issuer generates a CL signature on the attributes.

2.1.1 Choose a random prime

e ∈R [2ℓe−1, 2ℓe−1 + 2ℓ′

e−1] .

2.1.2 Choose a random integer ˜v ∈R {0, 1}ℓv−1, and compute v′′ = 2ℓv−1 + ˜v.
2.1.3 Look-up ﬁnite-set and binary attribute values {(aj, ej)}j∈AE

. Compute

E := Y
j∈AE

ej.

2.1.4 Compute

Q :=

Z

U (Qi∈AKN Rmi

i )(R

E=Qj∈AE
E

ej

)Sv′′

mod n and A := Qe−1 mod p′q′

mod n .

2.1.5 Send the pre-signature (A, e, v′′) to the Recipient.

Round 3: Signature Completion

3.0 Compute v := v′′ + v′.

3.1 Recipient veriﬁes (A, e, v), using the CL-sig veriﬁcation algorithm:

3.1.1 Check that e is prime, and e ∈ [2ℓe−1, 2ℓe−1 + 2ℓ′
3.1.2 Check that the values {ej}j∈AE
3.1.3 Compute ˆZ := AeSv(Qi∈S Rmi
3.1.4 If ˆZ 6≡ Z (mod n), abort IssueCertiﬁcateProtocol.

E=Qj∈AE
E

i )(R

from the Issuer public key are indeed prime.

e−1] .

ej

) mod n.

3.2 Recipient veriﬁes P2.

3.2.1 Compute ˆA := Ac′+seeSv′se mod n.
3.2.2 Compute ˆc = H(contextkQkAk ˆAkn2).
3.2.3 If ˆc 6= c′, abort IssueCertiﬁcateProtocol.

3.3 (output) If steps 3.1 and 3.2 succeed, store the certiﬁcate

(mi)i∈S, (aj, ej)j∈AE, (A, e, v)), l′ ≤ l.

B Bitlength Constraints of the Prime Encoding

Let us consider how many ﬁnite-set attributes we can compress in a single attribute base. We start with a
theoretical consideration and exemplify these thoughts with a practical example. Let us consider (1) which
attribute values are taken into account, (2) which bitlength their product consumes, and (3) what impact that
bitlength has.

26

h
t
g
n
e
l
t
i
b

4500

4000

3500

3000

2500

2000

1500

1000

500

0

0

100

200

n

300

400

Figure 1: Bitlength of product of the ﬁrst n primes. The graph starts with prime 5, we only count every
second prime.

We ﬁrst draw a distinction between an attribute and attribute realization. An attribute is a named set
of one or more values. Consider for instance the attribute profession with a value set of { none, doctor,
civil servant, teacher, . . . }. The value set is the set for the whole user population. It is important to observe
that any single user may only realize a small subset of these values. We call this subset attribute realization.
Even though there may exist hundreds of attribute values, a user usually only realizes a number and the
issuer can enforce an upper bound on it. Therefore, we will discuss the number of permissible attribute
realizations, not the number of attributes itself.

Second, we consider the bitlength consumed by attribute realizations. The issuer determines the maximal
bitlength of a possible attribute realization EMAX in the system. This is the bitlength of the corresponding
prime product. We note that the issuer can safely choose very small primes for the encoding, in fact, it
can start with prime 5. Let us for a moment analyze how the bitlength of such prime products grows. We
consider binary ﬂags, i.e., attributes with two associated prime values, where the user can only realize one of
them. Figure 1 depicts the growth of the bitlength of the products of n primes. We observe that the bitlength
of prime products shows an approximately linear growth for the ﬁrst few hundred numbers.

Third, the bitlength of attribute realizations has a two-fold impact. First, as the prime product exponent
E grows, the computation time for the corresponding exponentiation grows signiﬁcantly. Second and more
importantly, the possible bitlength of an attribute exponent in Camenisch-Lysyanskaya is limited by the
bitlength of the SRSA exponent e. This exponent needs to be resized as well to accommodate for attribute
realizations.

Let us consider the standard case according to the Identity Mixer speciﬁcation: the bitlength of e is
speciﬁed as 596 bits and the bitlength of an attribute limited to 256 bits. This allows for 37 binary attributes
to be stored without any change of system parameters. The user’s credential can realize one value for all 37
attributes at the same time.

C Professional Taxonomies

Virtually all professional organizations have elaborate taxonomies of expertise and attributes of clients and
objects. Most taxonomies are hierarchically organized and beneﬁt from statements on all their granularity
levels. The user may realize any sub-tree or path to a terminal leave from the full taxonomy tree.

27

Parameter

CL

Prime

Number of attribute bases
E. proof of possession

M. in AND-proof for PCCS
E. in AND-proof for PCCS

28
32

1
32

1
5

1
5

Table 4: Complexity in expertise scenario: CL requires one commitment and equality proof per relevant
attribute; the prime encoding’s proof of possession covers the AND-proof cost-free.

Expertise

Let us assume that the ACM decided to issue credentials to their members. These credentials shall contain
an expertise classiﬁcation according to the ACM Computing Classiﬁcation Scheme [2]. This well-known
taxonomy is a tree with depth four with eleven areas and roughly 1400 disciplines, sub-disciplines, and
topics. To encode one path to a terminal leaf of the taxonomy (e.g., “E. Data – 3. Data encryption –
Public key cryptosystems – PKI”), a traditional credential system would require four attribute bases. That
is, four bases per expertise area the user can realize at the same time. We assume that a ACM member
may choose three expertise areas. In addition, the ACM allows a choice from sixteen general terms, which
are in fact a multi-variate ﬁnite set. For this, a traditional credential system reserves additional bases. The
total number of required bases is proportional to the depth of the taxonomy times the potential attribute
realizations with an offset for the multi-variate ﬁnite set. The prime-encoding can represent arbitrarily many
attribute realizations in just one attribute base.

Let us assume that a user wants to prove the following policy PCCS:

expertise ⊃ {E.Data, 3.Encryption, E.3.PKI} ∧

expertise ⊃ {D.SW, 4.OS, 4.6.Security, 4.6.Auth} ∧

general ⊃ {performance, security}

This policy asks for an conjunction proof over all these attributes. We analyzed in Section 5.2.1 which steps
different encodings require. Our system encodes the proof as a single multi-element AND-proof integrated
in the proof of possession. We compare the complexity in Table 4.

Medical Records

Our new credential system impacts healthcare and medical record credentials tremendously. Healthcare
practitioners classify all diseases according to the International Statistical Classiﬁcation of Diseases and
Related Health Problems (ICD) [44, 45]. This is a taxonomy tree with depth ﬁve: chapters, sub-chapters,
section, class, and sub-class.13 Likewise, the Diagnostic and Statistical Manual of Mental Disorders (DSM-
VI-TR) [1, 43] is a taxonomy tree of depth ﬁve. Psychiatrists classify mental disorders according to ﬁve
axes, 16 categories, subcategories, disorder classes and sub-classes.14 To encode a single path in such a
taxonomy in a traditional credential system, one would require ﬁve attribute bases per realized terminal leaf.
And clearly, there is a need for specifying multiple symptoms or potential diagnoses.

13A classiﬁcation could for instance be “I. Determined infectious and parasitic diseases – Infectious diseases (A) – Infectious

abdominal diseases (A00–A09) – A01.- Typhus-alike – A01.2 Paratyphus B”

14For instance sleepwalking would be “Axis I – 13. Sleep disorders – Parasomnias – Sleepwalking”.

28

Parameter

CL

Prime

Number of attribute bases
E. proof of possession

M. in OR-proof for PMED
E. in OR-proof for PMED

25
29

28
83

1
5

9
23

Table 5: Complexity in medical scenario: CL requires one commitment to the disease attribute and 25
equality proofs; the prime encoding manages on two commitments and four relationship proofs.

Even though healthcare cards are still in their infancy, there are debates on storing certiﬁed medical
data on such cards. This option is very privacy-sensitive. Our proposal allows for selective-disclosure of
medical information according to standardized taxonomies with variable granularity. Implementing this on
smartcards with traditional credential systems is virtually impossible as the growing number of attribute
bases would render any proof of possession inefﬁcient. Our system allows to encode many realizations of
deep taxonomies within a single attribute base with strong performance improvements.

For instance, let us assume that user holds a certiﬁed diagnosis credential that may reserve ﬁve possible
path in the taxonomy. The policy PMED demands to prove that one of the diagnoses matches either one of
a set of, say 25, bacterial disease classes that are eligible for acquiring broad-spectrum antibiotics. Clearly,
it is highly desirable to hide the actual diagnosis in certain applications. Therefore, the proof must be done
with an OR-proof without disclosing the actual disease. This policy is similar to earlier OR-proofs, such as
exercised in Section 5.2.3, only restricted to a single relevant attribute. Our credential system does the same
proof a third of the term number and a fourth of the required exponentiations (Table 5).

29

